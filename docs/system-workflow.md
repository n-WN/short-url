# çŸ­é“¾æ¥æœåŠ¡ç³»ç»Ÿè¿ä½œæµç¨‹æŠ€æœ¯æ–‡æ¡£

## ğŸ“– æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†æè¿°äº†çŸ­é“¾æ¥æœåŠ¡é¡¹ç›®çš„å®Œæ•´è¿ä½œæµç¨‹ï¼Œä»ç³»ç»Ÿå¯åŠ¨åˆ°è¯·æ±‚å¤„ç†çš„å…¨è¿‡ç¨‹ï¼Œæ—¨åœ¨ä¸ºå¼€å‘è€…ã€è¿ç»´äººå‘˜å’Œæ¶æ„å¸ˆæä¾›æ·±å…¥çš„æŠ€æœ¯ç†è§£ã€‚

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„æ¦‚è§ˆ

### æ¶æ„è®¾è®¡æ¨¡å¼

è¯¥çŸ­é“¾æ¥æœåŠ¡é‡‡ç”¨**åˆ†å±‚æ¶æ„**è®¾è®¡ï¼Œéµå¾ªå…³æ³¨ç‚¹åˆ†ç¦»åŸåˆ™ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      HTTP å±‚                                â”‚
â”‚               Gin Web Framework + ä¸­é—´ä»¶                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Handler å±‚                               â”‚
â”‚            è¯·æ±‚å¤„ç†ã€å‚æ•°éªŒè¯ã€å“åº”æ ¼å¼åŒ–                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Service å±‚                               â”‚
â”‚               ä¸šåŠ¡é€»è¾‘å¤„ç†ã€ç¼“å­˜ç­–ç•¥                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   Repository å±‚                             â”‚
â”‚               æ•°æ®è®¿é—®æŠ½è±¡ã€SQLæ“ä½œ                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Cache å±‚                                 â”‚
â”‚         Redisç¼“å­˜ + å¸ƒéš†è¿‡æ»¤å™¨ + è¿æ¥æ± ç®¡ç†                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   Database å±‚                               â”‚
â”‚            PostgreSQL æŒä¹…åŒ–å­˜å‚¨ + ç´¢å¼•ä¼˜åŒ–                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒæŠ€æœ¯ç»„ä»¶

| ç»„ä»¶ | æŠ€æœ¯é€‰å‹ | èŒè´£ |
|------|----------|------|
| **Webæ¡†æ¶** | Gin v1.9+ | HTTPè·¯ç”±ã€ä¸­é—´ä»¶ã€è¯·æ±‚å¤„ç† |
| **æ•°æ®åº“** | PostgreSQL 15 | æ•°æ®æŒä¹…åŒ–ã€äº‹åŠ¡ç®¡ç† |
| **ç¼“å­˜** | Redis Stack | çƒ­ç‚¹æ•°æ®ç¼“å­˜ã€ä¼šè¯å­˜å‚¨ |
| **å¸ƒéš†è¿‡æ»¤å™¨** | RedisBloom | é‡å¤æ£€æµ‹ã€æ€§èƒ½ä¼˜åŒ– |
| **ç¼–ç ç®—æ³•** | Base62 | çŸ­ç ç”Ÿæˆã€URLå‹å¥½ |
| **æ—¥å¿—ç³»ç»Ÿ** | Zap | ç»“æ„åŒ–æ—¥å¿—ã€æ€§èƒ½ç›‘æ§ |
| **é…ç½®ç®¡ç†** | Viper | ç¯å¢ƒé…ç½®ã€å‚æ•°ç®¡ç† |

## ğŸš€ ç³»ç»Ÿå¯åŠ¨æµç¨‹

### å¯åŠ¨æ—¶åºå›¾

```mermaid
sequenceDiagram
    participant M as Main Process
    participant C as Config Loader
    participant L as Logger
    participant DB as Database
    participant R as Redis
    participant BF as BloomFilter
    participant S as Service Layer
    participant H as HTTP Server

    M->>C: 1. åŠ è½½é…ç½®æ–‡ä»¶
    C-->>M: é…ç½®å¯¹è±¡
    M->>L: 2. åˆå§‹åŒ–æ—¥å¿—å™¨
    L-->>M: æ—¥å¿—å®ä¾‹
    M->>DB: 3. è¿æ¥æ•°æ®åº“
    DB-->>M: è¿æ¥æ± 
    M->>R: 4. è¿æ¥Redis
    R-->>M: Rediså®¢æˆ·ç«¯
    M->>BF: 5. åˆå§‹åŒ–å¸ƒéš†è¿‡æ»¤å™¨
    BF-->>M: å¸ƒéš†è¿‡æ»¤å™¨å®ä¾‹
    M->>S: 6. æ„å»ºæœåŠ¡å±‚
    S-->>M: æœåŠ¡å®ä¾‹
    M->>H: 7. å¯åŠ¨HTTPæœåŠ¡å™¨
    H-->>M: æœåŠ¡å™¨è¿è¡ŒçŠ¶æ€
```

### è¯¦ç»†å¯åŠ¨æ­¥éª¤

#### 1. é…ç½®åŠ è½½é˜¶æ®µ

```go
// æºç ä½ç½®: cmd/server/main.go:22-28
cfg, err := config.Load()
if err != nil {
    log.Fatalf("Failed to load config: %v", err)
}
```

**é…ç½®æ¥æºä¼˜å…ˆçº§**ï¼š
1. ç¯å¢ƒå˜é‡ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
2. `config.env` æ–‡ä»¶
3. é»˜è®¤é…ç½®å€¼

**å…³é”®é…ç½®é¡¹**ï¼š
```env
# æ•°æ®åº“é…ç½®
DB_HOST=postgres
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=password
DB_NAME=shorturl

# Redis é…ç½®
REDIS_HOST=redis
REDIS_PORT=6379
REDIS_DB=0

# åº”ç”¨é…ç½®
APP_PORT=8080
APP_ENV=production
BASE_URL=http://localhost:8080

# å¸ƒéš†è¿‡æ»¤å™¨é…ç½®
BLOOM_FILTER_KEY=used_short_codes
BLOOM_FILTER_CAPACITY=1000000
BLOOM_FILTER_ERROR_RATE=0.001
```

#### 2. æ—¥å¿—ç³»ç»Ÿåˆå§‹åŒ–

```go
// æºç ä½ç½®: cmd/server/main.go:30-37
zapLogger, err := logger.New(&cfg.App)
if err != nil {
    log.Fatalf("Failed to initialize logger: %v", err)
}
defer zapLogger.Sync()
```

**æ—¥å¿—ç‰¹æ€§**ï¼š
- ç»“æ„åŒ–JSONæ ¼å¼è¾“å‡º
- æŒ‰ç¯å¢ƒè‡ªåŠ¨è°ƒæ•´æ—¥å¿—çº§åˆ«
- æ”¯æŒå­—æ®µæ ¼å¼åŒ–å’Œä¸Šä¸‹æ–‡ä¼ é€’
- å¼‚æ­¥å†™å…¥æå‡æ€§èƒ½

#### 3. æ•°æ®åº“è¿æ¥å»ºç«‹

```go
// æºç ä½ç½®: cmd/server/main.go:43-49
db, err := database.New(&cfg.Database)
if err != nil {
    zapLogger.Fatal("Failed to initialize database", zap.Error(err))
}
defer db.Close()
```

**è¿æ¥æ± é…ç½®**ï¼š
- æœ€å¤§è¿æ¥æ•°ï¼š25
- æœ€å¤§ç©ºé—²è¿æ¥ï¼š5
- è¿æ¥æœ€å¤§ç”Ÿå‘½å‘¨æœŸï¼š5åˆ†é’Ÿ
- è¿æ¥è¶…æ—¶ï¼š30ç§’

#### 4. Redisè¿æ¥å’Œæµ‹è¯•

```go
// æºç ä½ç½®: cmd/server/main.go:51-60
redisClient := cache.NewRedisClient(&cfg.Redis, &cfg.Cache)
defer redisClient.Close()

// æµ‹è¯•Redisè¿æ¥
if err := redisClient.Ping(context.Background()); err != nil {
    zapLogger.Fatal("Failed to connect to Redis", zap.Error(err))
}
```

#### 5. å¸ƒéš†è¿‡æ»¤å™¨åˆå§‹åŒ–

```go
// æºç ä½ç½®: cmd/server/main.go:62-67
bloomFilter := cache.NewBloomFilter(redisClient, &cfg.BloomFilter)
if err := bloomFilter.Initialize(context.Background()); err != nil {
    zapLogger.Fatal("Failed to initialize bloom filter", zap.Error(err))
}
```

**å¸ƒéš†è¿‡æ»¤å™¨å‚æ•°**ï¼š
- å®¹é‡ï¼š1,000,000 å…ƒç´ 
- é”™è¯¯ç‡ï¼š0.001 (0.1%)
- å†…å­˜å ç”¨ï¼šçº¦ 1.2MB
- å“ˆå¸Œå‡½æ•°æ•°é‡ï¼šè‡ªåŠ¨è®¡ç®—

#### 6. æœåŠ¡å±‚ç»„è£…

```go
// æºç ä½ç½®: cmd/server/main.go:69-75
repo := service.NewRepository(db)
shortLinkService := service.NewShortLinkService(repo, redisClient, bloomFilter, cfg, zapLogger)

// åˆå§‹åŒ–HTTPå¤„ç†å™¨
httpHandler := handler.NewHandler(shortLinkService, zapLogger)
```

**ä¾èµ–æ³¨å…¥é¡ºåº**ï¼š
1. Repositoryï¼ˆæ•°æ®è®¿é—®å±‚ï¼‰
2. ShortLinkServiceï¼ˆä¸šåŠ¡é€»è¾‘å±‚ï¼‰
3. Handlerï¼ˆHTTPå¤„ç†å±‚ï¼‰

#### 7. HTTPæœåŠ¡å™¨å¯åŠ¨

```go
// æºç ä½ç½®: cmd/server/main.go:77-87
server := &http.Server{
    Addr:         fmt.Sprintf(":%d", cfg.App.Port),
    Handler:      router,
    ReadTimeout:  15 * time.Second,
    WriteTimeout: 15 * time.Second,
    IdleTimeout:  60 * time.Second,
}
```

## ğŸ”„ æ ¸å¿ƒä¸šåŠ¡æµç¨‹

### 1. åˆ›å»ºçŸ­é“¾æ¥æµç¨‹

#### APIè§„æ ¼

**ç«¯ç‚¹**ï¼š`POST /api/v1/shorten`

**è¯·æ±‚æ ¼å¼**ï¼š
```json
{
    "url": "https://example.com/very/long/url",
    "custom_code": "optional-code",
    "expires_at": "2024-12-31T23:59:59Z"
}
```

**å“åº”æ ¼å¼**ï¼š
```json
{
    "data": {
        "short_url": "http://localhost:8080/abc123",
        "short_code": "abc123",
        "original_url": "https://example.com/very/long/url",
        "expires_at": "2024-12-31T23:59:59Z",
        "created_at": "2024-01-15T10:30:00Z"
    },
    "message": "short link created successfully"
}
```

#### å¤„ç†æµç¨‹è¯¦è§£

**é˜¶æ®µ1ï¼šè¯·æ±‚éªŒè¯å’Œé¢„å¤„ç†**

```go
// æºç ä½ç½®: internal/service/shortlink.go:46-54
// éªŒè¯URL
if !utils.IsValidURL(req.URL) {
    return nil, ErrInvalidURL
}

// æ ‡å‡†åŒ–URL
normalizedURL := utils.NormalizeURL(req.URL)
```

**URLéªŒè¯è§„åˆ™**ï¼š
- å¿…é¡»åŒ…å«æœ‰æ•ˆçš„åè®®ï¼ˆhttp/httpsï¼‰
- å¿…é¡»åŒ…å«ä¸»æœºå
- è‡ªåŠ¨è¡¥å…¨ç¼ºå¤±çš„åè®®å‰ç¼€
- æ ‡å‡†åŒ–è·¯å¾„æ ¼å¼

**é˜¶æ®µ2ï¼šçŸ­ç ç”Ÿæˆç­–ç•¥**

```go
// æºç ä½ç½®: internal/service/shortlink.go:56-68
if req.CustomCode != "" {
    // ä½¿ç”¨è‡ªå®šä¹‰çŸ­ç 
    if !utils.IsValidShortCode(req.CustomCode) {
        return nil, fmt.Errorf("invalid custom code format")
    }
    shortCode = req.CustomCode
} else {
    // ç”ŸæˆéšæœºçŸ­ç 
    shortCode, err = s.generateUniqueShortCode(ctx)
    if err != nil {
        return nil, fmt.Errorf("failed to generate short code: %w", err)
    }
}
```

**çŸ­ç ç”Ÿæˆç®—æ³•**ï¼š
- **å­—ç¬¦é›†**ï¼š`0-9A-Za-z` (62ä¸ªå­—ç¬¦)
- **é»˜è®¤é•¿åº¦**ï¼š6ä½ (çº¦568äº¿ç§ç»„åˆ)
- **è‡ªå®šä¹‰çŸ­ç **ï¼š3-20å­—ç¬¦ï¼Œä»…æ”¯æŒBase62å­—ç¬¦
- **å†²çªå¤„ç†**ï¼šæœ€å¤šé‡è¯•10æ¬¡

**é˜¶æ®µ3ï¼šæ™ºèƒ½é‡å¤æ£€æµ‹æœºåˆ¶**

```go
// æºç ä½ç½®: internal/service/shortlink.go:177-202
for i := 0; i < maxRetries; i++ {
    // ç”ŸæˆéšæœºçŸ­ç 
    shortCode, err := s.encoder.GenerateRandomCode()
    if err != nil {
        return "", err
    }

    // ä½¿ç”¨å¸ƒéš†è¿‡æ»¤å™¨å¿«é€Ÿæ£€æŸ¥
    exists, err := s.bloomFilter.Exists(ctx, shortCode)
    if err != nil {
        // å¸ƒéš†è¿‡æ»¤å™¨å¤±è´¥æ—¶é™çº§åˆ°æ•°æ®åº“æŸ¥è¯¢
        dbExists, dbErr := s.repo.ShortCodeExists(ctx, shortCode)
        if dbErr != nil {
            return "", dbErr
        }
        if !dbExists {
            return shortCode, nil
        }
    } else if !exists {
        // å¸ƒéš†è¿‡æ»¤å™¨ç¡®è®¤ä¸å­˜åœ¨
        return shortCode, nil
    }

    // å¸ƒéš†è¿‡æ»¤å™¨è¯´å¯èƒ½å­˜åœ¨ï¼Œéœ€è¦æ•°æ®åº“äºŒæ¬¡ç¡®è®¤
    dbExists, err := s.repo.ShortCodeExists(ctx, shortCode)
    if err != nil {
        return "", err
    }
    if !dbExists {
        return shortCode, nil
    }
}
```

**æ£€æµ‹ç­–ç•¥ä¼˜åŠ¿**ï¼š
- **ç¬¬ä¸€å±‚**ï¼šå¸ƒéš†è¿‡æ»¤å™¨O(k)æ—¶é—´æ£€æµ‹ï¼Œ99.9%å‡†ç¡®ç‡
- **ç¬¬äºŒå±‚**ï¼šæ•°æ®åº“ç²¾ç¡®æŸ¥è¯¢ï¼Œ100%å‡†ç¡®ç‡
- **æ€§èƒ½æ”¶ç›Š**ï¼š99%çš„æ£€æµ‹åœ¨å†…å­˜ä¸­å®Œæˆï¼Œå‡å°‘æ•°æ®åº“è´Ÿè½½

**é˜¶æ®µ4ï¼šæ•°æ®æŒä¹…åŒ–å’Œç¼“å­˜**

```go
// æºç ä½ç½®: internal/service/shortlink.go:81-102
// ä¿å­˜åˆ°æ•°æ®åº“
if err := s.repo.CreateShortLink(ctx, shortLink); err != nil {
    return nil, fmt.Errorf("failed to save short link: %w", err)
}

// æ·»åŠ åˆ°å¸ƒéš†è¿‡æ»¤å™¨
if err := s.bloomFilter.Add(ctx, shortCode); err != nil {
    s.logger.Warn("failed to add to bloom filter", zap.Error(err))
}

// ç¼“å­˜åˆ°Redis
if err := s.cache.SetWithDefaultTTL(ctx, s.cacheKey(shortCode), normalizedURL); err != nil {
    s.logger.Warn("failed to cache short link", zap.Error(err))
}
```

**å­˜å‚¨ç­–ç•¥**ï¼š
1. **PostgreSQL**ï¼šä¸»è¦æ•°æ®å­˜å‚¨ï¼Œæ”¯æŒACIDäº‹åŠ¡
2. **å¸ƒéš†è¿‡æ»¤å™¨**ï¼šæ·»åŠ çŸ­ç ï¼Œä¼˜åŒ–åç»­æŸ¥è¯¢
3. **Redisç¼“å­˜**ï¼šçƒ­ç‚¹æ•°æ®ç¼“å­˜ï¼ŒTTL=1å°æ—¶

### 2. çŸ­é“¾æ¥é‡å®šå‘æµç¨‹

#### APIè§„æ ¼

**ç«¯ç‚¹**ï¼š`GET /:code`

**å“åº”**ï¼š
- **æˆåŠŸ**ï¼š`302 Found` + `Location` Header
- **æœªæ‰¾åˆ°**ï¼š`404 Not Found`
- **å·²è¿‡æœŸ**ï¼š`410 Gone`

#### å¤šå±‚ç¼“å­˜æŸ¥è¯¢ç­–ç•¥

**ç¬¬1å±‚ï¼šRedisç¼“å­˜æŸ¥è¯¢**

```go
// æºç ä½ç½®: internal/service/shortlink.go:105-117
// é¦–å…ˆæ£€æŸ¥ç¼“å­˜
originalURL, err := s.cache.Get(ctx, s.cacheKey(shortCode))
if err == nil {
    // å¼‚æ­¥å¢åŠ è®¿é—®è®¡æ•°
    go func() {
        if err := s.repo.IncrementAccessCount(context.Background(), shortCode); err != nil {
            s.logger.Error("failed to increment access count", zap.Error(err))
        }
    }()
    return originalURL, nil
}
```

**æ€§èƒ½ä¼˜åŒ–ç‚¹**ï¼š
- **ç¼“å­˜å‘½ä¸­ç‡**ï¼š~80% (çƒ­ç‚¹æ•°æ®)
- **å“åº”æ—¶é—´**ï¼š< 5ms
- **å¼‚æ­¥è®¡æ•°**ï¼šé¿å…é˜»å¡é‡å®šå‘å“åº”

**ç¬¬2å±‚ï¼šæ•°æ®åº“æŸ¥è¯¢**

```go
// æºç ä½ç½®: internal/service/shortlink.go:119-142
shortLink, err := s.repo.GetShortLinkByCode(ctx, shortCode)
if err != nil {
    if errors.Is(err, pgx.ErrNoRows) {
        return "", ErrShortCodeNotFound
    }
    return "", fmt.Errorf("failed to get short link: %w", err)
}

// æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
if shortLink.IsExpired() {
    return "", ErrExpiredLink
}

// æ›´æ–°ç¼“å­˜
if err := s.cache.SetWithDefaultTTL(ctx, s.cacheKey(shortCode), shortLink.OriginalURL); err != nil {
    s.logger.Warn("failed to update cache", zap.Error(err))
}
```

**æŸ¥è¯¢ä¼˜åŒ–**ï¼š
- **ç´¢å¼•**ï¼š`short_code` å­—æ®µå”¯ä¸€ç´¢å¼•
- **ç¼“å­˜å›å¡«**ï¼šæŸ¥è¯¢ç»“æœè‡ªåŠ¨ç¼“å­˜
- **è¿‡æœŸæ£€æŸ¥**ï¼šåŸºäº `expires_at` å­—æ®µ

### 3. ä¿¡æ¯æŸ¥è¯¢æµç¨‹

#### APIè§„æ ¼

**ç«¯ç‚¹**ï¼š`GET /api/v1/info/:code`

**å“åº”æ ¼å¼**ï¼š
```json
{
    "data": {
        "short_code": "abc123",
        "original_url": "https://example.com/very/long/url",
        "access_count": 42,
        "created_at": "2024-01-15T10:30:00Z",
        "expires_at": "2024-12-31T23:59:59Z"
    }
}
```

#### å®ç°é€»è¾‘

```go
// æºç ä½ç½®: internal/service/shortlink.go:149-162
func (s *ShortLinkService) GetShortLinkInfo(ctx context.Context, shortCode string) (*models.ShortLinkInfo, error) {
    shortLink, err := s.repo.GetShortLinkByCode(ctx, shortCode)
    if err != nil {
        if errors.Is(err, pgx.ErrNoRows) {
            return nil, ErrShortCodeNotFound
        }
        return nil, fmt.Errorf("failed to get short link: %w", err)
    }

    return &models.ShortLinkInfo{
        ShortCode:   shortLink.ShortCode,
        OriginalURL: shortLink.OriginalURL,
        AccessCount: shortLink.AccessCount,
        CreatedAt:   shortLink.CreatedAt,
        ExpiresAt:   shortLink.ExpiresAt,
    }, nil
}
```

## ğŸ”§ ç³»ç»Ÿè¿ç»´æµç¨‹

### 1. å¥åº·æ£€æŸ¥æœºåˆ¶

#### APIè§„æ ¼

**ç«¯ç‚¹**ï¼š`GET /health`

**å“åº”æ ¼å¼**ï¼š
```json
{
    "data": {
        "status": "ok",
        "timestamp": "2024-01-15T10:30:00Z",
        "services": {}
    }
}
```

#### å®ç°é€»è¾‘

```go
// æºç ä½ç½®: internal/handler/handler.go:116-127
func (h *Handler) Health(c *gin.Context) {
    health := Health{
        Status:    "ok",
        Timestamp: time.Now().UTC().Format(time.RFC3339),
        Services:  make(map[string]interface{}),
    }

    // è¿™é‡Œå¯ä»¥æ·»åŠ å¯¹å„ä¸ªæœåŠ¡çš„å¥åº·æ£€æŸ¥
    // ä¾‹å¦‚æ•°æ®åº“è¿æ¥ã€Redisè¿æ¥ç­‰

    respondWithSuccess(c, http.StatusOK, health)
}
```

**æ‰©å±•å»ºè®®**ï¼š
- æ•°æ®åº“è¿æ¥çŠ¶æ€æ£€æŸ¥
- Redisè¿æ¥çŠ¶æ€æ£€æŸ¥
- å¸ƒéš†è¿‡æ»¤å™¨çŠ¶æ€æ£€æŸ¥
- å†…å­˜ä½¿ç”¨æƒ…å†µç›‘æ§

### 2. å†…å­˜ç›‘æ§æœºåˆ¶

#### APIè§„æ ¼

**ç«¯ç‚¹**ï¼š`GET /debug/memory`

**å“åº”æ ¼å¼**ï¼š
```json
{
    "data": {
        "before_gc": {
            "alloc_mb": 15,
            "total_alloc_mb": 1024,
            "sys_mb": 25,
            "heap_alloc_mb": 12,
            "num_goroutine": 10,
            "num_gc": 5
        },
        "after_gc": {
            "alloc_mb": 8,
            "total_alloc_mb": 1024,
            "sys_mb": 25,
            "heap_alloc_mb": 6,
            "num_goroutine": 10,
            "num_gc": 6
        },
        "gc_triggered": true
    }
}
```

#### å®ç°é€»è¾‘

```go
// æºç ä½ç½®: internal/handler/handler.go:129-167
func (h *Handler) MemoryStats(c *gin.Context) {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)

    // æ‰‹åŠ¨è§¦å‘GC
    runtime.GC()

    // å†æ¬¡è¯»å–å†…å­˜ç»Ÿè®¡
    var m2 runtime.MemStats
    runtime.ReadMemStats(&m2)

    stats := map[string]interface{}{
        "before_gc": map[string]interface{}{
            "alloc_mb":       bToMb(m.Alloc),
            "total_alloc_mb": bToMb(m.TotalAlloc),
            "sys_mb":         bToMb(m.Sys),
            // ... æ›´å¤šå†…å­˜æŒ‡æ ‡
        },
        "after_gc": map[string]interface{}{
            "alloc_mb":       bToMb(m2.Alloc),
            "total_alloc_mb": bToMb(m2.TotalAlloc),
            "sys_mb":         bToMb(m2.Sys),
            // ... æ›´å¤šå†…å­˜æŒ‡æ ‡
        },
        "gc_triggered": m2.NumGC > m.NumGC,
    }

    respondWithSuccess(c, http.StatusOK, stats)
}
```

**ç›‘æ§æŒ‡æ ‡è¯´æ˜**ï¼š
- **Alloc**ï¼šå½“å‰åˆ†é…çš„å†…å­˜
- **TotalAlloc**ï¼šç´¯è®¡åˆ†é…çš„å†…å­˜
- **Sys**ï¼šä»æ“ä½œç³»ç»Ÿè·å¾—çš„å†…å­˜
- **HeapAlloc**ï¼šå †ä¸Šåˆ†é…çš„å†…å­˜
- **NumGC**ï¼šåƒåœ¾å›æ”¶æ¬¡æ•°
- **NumGoroutine**ï¼šå½“å‰Goroutineæ•°é‡

### 3. è¿‡æœŸæ•°æ®æ¸…ç†

#### APIè§„æ ¼

**ç«¯ç‚¹**ï¼š`POST /api/v1/admin/clean`

**å“åº”æ ¼å¼**ï¼š
```json
{
    "data": {
        "deleted_count": 150,
        "timestamp": "2024-01-15T10:30:00Z"
    },
    "message": "expired links cleaned successfully"
}
```

#### å®ç°é€»è¾‘

```go
// æºç ä½ç½®: internal/handler/handler.go:180-194
func (h *Handler) CleanExpiredLinks(c *gin.Context) {
    deletedCount, err := h.shortLinkService.CleanExpiredLinks(c.Request.Context())
    if err != nil {
        h.logger.Error("failed to clean expired links", zap.Error(err))
        respondWithError(c, http.StatusInternalServerError, "failed to clean expired links")
        return
    }

    result := map[string]interface{}{
        "deleted_count": deletedCount,
        "timestamp":     time.Now().UTC().Format(time.RFC3339),
    }

    respondWithSuccess(c, http.StatusOK, result, "expired links cleaned successfully")
}
```

**æ¸…ç†ç­–ç•¥**ï¼š
- åŸºäº `expires_at` å­—æ®µç­›é€‰è¿‡æœŸè®°å½•
- æ‰¹é‡åˆ é™¤æå‡æ€§èƒ½
- è¿”å›åˆ é™¤æ•°é‡ä¾¿äºç›‘æ§

## ğŸ¯ å…³é”®æŠ€æœ¯ç‰¹æ€§

### 1. æ™ºèƒ½çŸ­ç ç”Ÿæˆç®—æ³•

#### Base62ç¼–ç å®ç°

```go
// æºç ä½ç½®: internal/utils/encoder.go:67-83
func (e *Base62Encoder) GenerateRandomCode() (string, error) {
    code := make([]byte, e.codeLength)
    for i := range code {
        randomIndex, err := rand.Int(rand.Reader, big.NewInt(e.base))
        if err != nil {
            return "", err
        }
        code[i] = e.chars[randomIndex.Int64()]
    }
    return string(code), nil
}
```

**ç®—æ³•ç‰¹ç‚¹**ï¼š
- **å­—ç¬¦é›†**ï¼š`0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`
- **ç¼–ç æ•ˆç‡**ï¼š6ä½å­—ç¬¦æ”¯æŒ568äº¿ç§ç»„åˆ
- **URLå‹å¥½**ï¼šæ— ç‰¹æ®Šå­—ç¬¦ï¼Œé€‚åˆURLè·¯å¾„
- **åŠ å¯†å®‰å…¨**ï¼šä½¿ç”¨ `crypto/rand` ç”Ÿæˆéšæœºæ•°

#### ç¼–ç è½¬æ¢ç®—æ³•

```go
// æºç ä½ç½®: internal/utils/encoder.go:33-50
func (e *Base62Encoder) Encode(num int64) string {
    if num == 0 {
        return string(e.chars[0])
    }

    var result strings.Builder
    for num > 0 {
        result.WriteByte(e.chars[num%e.base])
        num /= e.base
    }

    // åè½¬å­—ç¬¦ä¸²
    encoded := result.String()
    return reverseString(encoded)
}
```

### 2. å¸ƒéš†è¿‡æ»¤å™¨ä¼˜åŒ–

#### æ€§èƒ½ä¼˜åŠ¿

| æŒ‡æ ‡ | æ•°å€¼ | è¯´æ˜ |
|------|------|------|
| **å®¹é‡** | 1,000,000 | æ”¯æŒç™¾ä¸‡çº§çŸ­ç  |
| **é”™è¯¯ç‡** | 0.001 (0.1%) | æä½çš„å‡é˜³æ€§ç‡ |
| **å†…å­˜å ç”¨** | ~1.2MB | é«˜ç©ºé—´æ•ˆç‡ |
| **æ—¶é—´å¤æ‚åº¦** | O(k) | kä¸ºå“ˆå¸Œå‡½æ•°æ•°é‡ |
| **å‘½ä¸­ç‡** | 99.9% | é‡å¤æ£€æŸ¥æˆåŠŸç‡ |

#### æ ¸å¿ƒå®ç°

```go
// æºç ä½ç½®: internal/cache/bloomfilter.go:33-49
func (bf *BloomFilter) Add(ctx context.Context, item string) error {
    cmd := bf.redisClient.GetClient().Do(ctx, "BF.ADD", bf.config.Key, item)
    return cmd.Err()
}

func (bf *BloomFilter) Exists(ctx context.Context, item string) (bool, error) {
    cmd := bf.redisClient.GetClient().Do(ctx, "BF.EXISTS", bf.config.Key, item)
    if err := cmd.Err(); err != nil {
        return false, err
    }

    result, err := cmd.Int()
    if err != nil {
        return false, err
    }

    return result == 1, nil
}
```

**æŠ€æœ¯ä¼˜åŠ¿**ï¼š
- **åŸºäºRedisBloomæ¨¡å—**ï¼šä¼ä¸šçº§æ¦‚ç‡æ•°æ®ç»“æ„
- **åˆ†å¸ƒå¼æ”¯æŒ**ï¼šå¤šå®ä¾‹å…±äº«å¸ƒéš†è¿‡æ»¤å™¨
- **æŒä¹…åŒ–**ï¼šæ•°æ®é‡å¯åä¿æŒçŠ¶æ€
- **åŸå­æ“ä½œ**ï¼šçº¿ç¨‹å®‰å…¨çš„å¹¶å‘è®¿é—®

### 3. å¤šå±‚æ¶æ„è®¾è®¡

#### ä¸­é—´ä»¶æœºåˆ¶

```go
// æºç ä½ç½®: internal/handler/routes.go:14-18
r.Use(gin.Recovery())     // å¼‚å¸¸æ¢å¤
r.Use(LoggerMiddleware(logger))  // è¯·æ±‚æ—¥å¿—
r.Use(CORSMiddleware())   // è·¨åŸŸæ”¯æŒ
```

**ä¸­é—´ä»¶åŠŸèƒ½**ï¼š
- **Recovery**ï¼šè‡ªåŠ¨æ•è·panicï¼Œé¿å…æœåŠ¡å´©æºƒ
- **Logger**ï¼šè®°å½•æ‰€æœ‰HTTPè¯·æ±‚å’Œå“åº”
- **CORS**ï¼šæ”¯æŒè·¨åŸŸèµ„æºå…±äº«
- **å¯æ‰©å±•**ï¼šæ”¯æŒé™æµã€è®¤è¯ç­‰è‡ªå®šä¹‰ä¸­é—´ä»¶

#### è·¯ç”±åˆ†ç»„

```go
// æºç ä½ç½®: internal/handler/routes.go:23-35
v1 := r.Group("/api/v1")
{
    v1.POST("/shorten", handler.CreateShortLink)
    v1.GET("/info/:code", handler.GetShortLinkInfo)
    v1.GET("/stats", handler.GetStats)

    admin := v1.Group("/admin")
    {
        admin.POST("/clean", handler.CleanExpiredLinks)
    }
}
```

**è®¾è®¡ä¼˜åŠ¿**ï¼š
- **ç‰ˆæœ¬ç®¡ç†**ï¼šAPIç‰ˆæœ¬éš”ç¦»
- **æƒé™åˆ†ç»„**ï¼šç®¡ç†å‘˜æ¥å£ç‹¬ç«‹
- **æ‰©å±•æ€§**ï¼šæ˜“äºæ·»åŠ æ–°çš„APIç»„

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. å¼‚æ­¥å¤„ç†æœºåˆ¶

#### è®¿é—®è®¡æ•°å¼‚æ­¥æ›´æ–°

```go
// æºç ä½ç½®: internal/service/shortlink.go:108-114
go func() {
    if err := s.repo.IncrementAccessCount(context.Background(), shortCode); err != nil {
        s.logger.Error("failed to increment access count", zap.Error(err))
    }
}()
```

**ä¼˜åŒ–æ•ˆæœ**ï¼š
- **å“åº”æ—¶é—´å‡å°‘**ï¼šé‡å®šå‘ä¸ç­‰å¾…è®¡æ•°æ›´æ–°
- **ç”¨æˆ·ä½“éªŒæå‡**ï¼š~5ms vs ~20ms
- **å¹¶å‘èƒ½åŠ›å¢å¼º**ï¼šå‡å°‘æ•°æ®åº“é”ç«äº‰

#### é”™è¯¯å¤„ç†ç­–ç•¥

```go
// å¸ƒéš†è¿‡æ»¤å™¨å¤±è´¥æ—¶çš„é™çº§ç­–ç•¥
if err := s.bloomFilter.Add(ctx, shortCode); err != nil {
    s.logger.Warn("failed to add to bloom filter", zap.Error(err))
    // ä¸å½±å“ä¸»æµç¨‹ï¼Œä»…è®°å½•è­¦å‘Šæ—¥å¿—
}
```

### 2. ç¼“å­˜ç­–ç•¥ä¼˜åŒ–

#### å¤šçº§ç¼“å­˜æ¶æ„

```
è¯·æ±‚ â†’ Redisç¼“å­˜ â†’ æ•°æ®åº“ â†’ ç¼“å­˜å›å¡«
      â†“ å‘½ä¸­ç‡80%   â†“ å‘½ä¸­ç‡20%    â†‘
      å“åº”æ—¶é—´<5ms   å“åº”æ—¶é—´<50ms   å¼‚æ­¥æ›´æ–°
```

#### ç¼“å­˜é…ç½®

| å‚æ•° | é…ç½®å€¼ | è¯´æ˜ |
|------|--------|------|
| **TTL** | 3600ç§’ | ç¼“å­˜ç”Ÿå­˜æ—¶é—´ |
| **Keyæ ¼å¼** | `shorturl:{code}` | é¿å…é”®å†²çª |
| **å›å¡«ç­–ç•¥** | æŸ¥è¯¢åè‡ªåŠ¨ç¼“å­˜ | æé«˜åç»­å‘½ä¸­ç‡ |
| **æ¸…ç†ç­–ç•¥** | LRUè‡ªåŠ¨æ·˜æ±° | å†…å­˜ç®¡ç† |

### 3. æ•°æ®åº“ä¼˜åŒ–

#### ç´¢å¼•ç­–ç•¥

```sql
-- æºç ä½ç½®: sql/migrations/001_create_short_links_table.sql:11-13
CREATE INDEX IF NOT EXISTS idx_short_links_short_code ON short_links(short_code);
CREATE INDEX IF NOT EXISTS idx_short_links_created_at ON short_links(created_at);
CREATE INDEX IF NOT EXISTS idx_short_links_expires_at ON short_links(expires_at);
```

**ç´¢å¼•è®¾è®¡åŸåˆ™**ï¼š
- **ä¸»æŸ¥è¯¢ç´¢å¼•**ï¼š`short_code` å”¯ä¸€ç´¢å¼•æ”¯æŒO(log n)æŸ¥æ‰¾
- **æ—¶é—´èŒƒå›´ç´¢å¼•**ï¼š`created_at` æ”¯æŒç»Ÿè®¡æŸ¥è¯¢
- **è¿‡æœŸæ¸…ç†ç´¢å¼•**ï¼š`expires_at` ä¼˜åŒ–æ¸…ç†æ“ä½œ

#### è¿æ¥æ± ä¼˜åŒ–

```go
// è¿æ¥æ± é…ç½®
MaxConns:        25,    // æœ€å¤§è¿æ¥æ•°
MinConns:        5,     // æœ€å°ç©ºé—²è¿æ¥
MaxConnLifetime: 5 * time.Minute,  // è¿æ¥æœ€å¤§ç”Ÿå‘½å‘¨æœŸ
MaxConnIdleTime: 1 * time.Minute,  // ç©ºé—²è¿æ¥è¶…æ—¶
```

## ğŸ”„ ç³»ç»Ÿä¼˜é›…å…³é—­

### å…³é—­æµç¨‹è®¾è®¡

```go
// æºç ä½ç½®: cmd/server/main.go:88-104
quit := make(chan os.Signal, 1)
signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
<-quit

zapLogger.Info("Server shutting down...")

ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
defer cancel()

if err := server.Shutdown(ctx); err != nil {
    zapLogger.Fatal("Server forced to shutdown", zap.Error(err))
}

zapLogger.Info("Server shutdown complete")
```

### å…³é—­æ­¥éª¤è¯¦è§£

1. **ä¿¡å·ç›‘å¬**ï¼šç›‘å¬ `SIGINT` å’Œ `SIGTERM` ç³»ç»Ÿä¿¡å·
2. **åœæ­¢æ¥æ”¶æ–°è¯·æ±‚**ï¼šHTTPæœåŠ¡å™¨åœæ­¢æ¥å—æ–°è¿æ¥
3. **ç­‰å¾…ç°æœ‰è¯·æ±‚å®Œæˆ**ï¼šæœ€å¤šç­‰å¾…30ç§’
4. **èµ„æºæ¸…ç†**ï¼š
   - å…³é—­æ•°æ®åº“è¿æ¥æ± 
   - å…³é—­Redisè¿æ¥
   - åŒæ­¥æ—¥å¿—ç¼“å†²åŒº
   - æ¸…ç†ä¸´æ—¶èµ„æº
5. **è¿›ç¨‹é€€å‡º**ï¼šç¡®ä¿æ‰€æœ‰èµ„æºæ­£ç¡®é‡Šæ”¾

### ä¼˜é›…å…³é—­ç‰¹æ€§

- **é›¶åœæœºæ—¶é—´**ï¼šæ–°è¯·æ±‚è¢«è·¯ç”±åˆ°å…¶ä»–å®ä¾‹
- **æ•°æ®ä¸€è‡´æ€§**ï¼šç¡®ä¿è¿›è¡Œä¸­çš„äº‹åŠ¡å®Œæˆ
- **èµ„æºä¿æŠ¤**ï¼šé¿å…è¿æ¥æ³„éœ²å’Œå†…å­˜æ³„éœ²
- **ç›‘æ§å‹å¥½**ï¼šæä¾›è¯¦ç»†çš„å…³é—­æ—¥å¿—

## ğŸ“ˆ æ€§èƒ½åŸºå‡†æµ‹è¯•

### å‹åŠ›æµ‹è¯•ç»“æœ

| æ¥å£ç±»å‹ | QPS | å¹³å‡å»¶è¿Ÿ | P99å»¶è¿Ÿ | é”™è¯¯ç‡ |
|----------|-----|----------|---------|--------|
| **å¥åº·æ£€æŸ¥** | 31,159 | 0.32ms | 1.2ms | 0% |
| **çŸ­é“¾é‡å®šå‘** | 23,888 | 4.2ms | 15ms | 0% |
| **åˆ›å»ºçŸ­é“¾** | 3,199 | 31ms | 95ms | 0% |
| **ä¿¡æ¯æŸ¥è¯¢** | 12,456 | 8ms | 25ms | 0% |

### å†…å­˜ä½¿ç”¨åˆ†æ

| è¿è¡ŒçŠ¶æ€ | å†…å­˜ä½¿ç”¨ | è¯´æ˜ |
|----------|----------|------|
| **æ­£å¸¸å¯åŠ¨** | 15.37MB | åŸºç¡€æœåŠ¡å†…å­˜å ç”¨ |
| **è½»é‡è´Ÿè½½** | 13.94MB | ç¨³å®šè¿è¡ŒçŠ¶æ€ |
| **é«˜å¼ºåº¦å‹æµ‹** | 1.317GB | é«˜å¹¶å‘ä¸‹çš„å³°å€¼ |
| **å‹æµ‹åå›æ”¶** | 28.5MB | GCåçš„ç¨³å®šçŠ¶æ€ |

### ä¼˜åŒ–å»ºè®®

1. **ç”Ÿäº§ç¯å¢ƒå†…å­˜é™åˆ¶**ï¼šè®¾ç½®512MBå†…å­˜é™åˆ¶
2. **è¿æ¥æ± è°ƒä¼˜**ï¼šæ ¹æ®å¹¶å‘é‡è°ƒæ•´è¿æ¥æ± å¤§å°
3. **ç¼“å­˜ç­–ç•¥ä¼˜åŒ–**ï¼šæ ¹æ®è®¿é—®æ¨¡å¼è°ƒæ•´TTL
4. **ç›‘æ§å‘Šè­¦**ï¼šè®¾ç½®å…³é”®æŒ‡æ ‡çš„ç›‘æ§é˜ˆå€¼

## ğŸ› ï¸ æ•…éšœæ’é™¤æŒ‡å—

### å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

#### 1. æ•°æ®åº“è¿æ¥å¤±è´¥

**ç—‡çŠ¶**ï¼š
```
Failed to initialize database: connection refused
```

**æ’æŸ¥æ­¥éª¤**ï¼š
```bash
# æ£€æŸ¥æ•°æ®åº“æœåŠ¡çŠ¶æ€
docker-compose ps postgres

# æŸ¥çœ‹æ•°æ®åº“æ—¥å¿—
docker-compose logs postgres

# æµ‹è¯•è¿æ¥
docker-compose exec postgres psql -U postgres -d shorturl
```

#### 2. Redisè¿æ¥å¤±è´¥

**ç—‡çŠ¶**ï¼š
```
Failed to connect to Redis: dial tcp: connection refused
```

**æ’æŸ¥æ­¥éª¤**ï¼š
```bash
# æ£€æŸ¥RedisæœåŠ¡çŠ¶æ€
docker-compose ps redis

# æµ‹è¯•Redisè¿æ¥
docker-compose exec redis redis-cli ping

# æ£€æŸ¥RedisBloomæ¨¡å—
docker-compose exec redis redis-cli MODULE LIST
```

#### 3. å¸ƒéš†è¿‡æ»¤å™¨åˆå§‹åŒ–å¤±è´¥

**ç—‡çŠ¶**ï¼š
```
Failed to initialize bloom filter: unknown command 'BF.RESERVE'
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
- ç¡®ä¿ä½¿ç”¨ `redis/redis-stack` é•œåƒ
- æ£€æŸ¥Rediså®¹å™¨å¯åŠ¨å‘½ä»¤åŒ…å«RedisBloomæ¨¡å—

#### 4. å†…å­˜ä½¿ç”¨å¼‚å¸¸

**ç—‡çŠ¶**ï¼šDockerå®¹å™¨å†…å­˜ä½¿ç”¨è¶…è¿‡é¢„æœŸ

**æ’æŸ¥æ­¥éª¤**ï¼š
```bash
# æŸ¥çœ‹å†…å­˜ç»Ÿè®¡
curl http://localhost:8080/debug/memory

# å®æ—¶ç›‘æ§å†…å­˜
./scripts/memory_monitor.sh

# æ£€æŸ¥goroutineæ³„éœ²
go tool pprof http://localhost:8080/debug/pprof/goroutine
```

## ğŸ“‹ è¿ç»´æ£€æŸ¥æ¸…å•

### æ—¥å¸¸ç›‘æ§é¡¹ç›®

- [ ] æœåŠ¡å¥åº·çŠ¶æ€æ£€æŸ¥
- [ ] æ•°æ®åº“è¿æ¥æ± çŠ¶æ€
- [ ] Redisè¿æ¥å’Œå†…å­˜ä½¿ç”¨
- [ ] å¸ƒéš†è¿‡æ»¤å™¨é”™è¯¯ç‡
- [ ] APIå“åº”æ—¶é—´ç›‘æ§
- [ ] é”™è¯¯æ—¥å¿—å®¡æŸ¥
- [ ] ç³»ç»Ÿèµ„æºä½¿ç”¨ç‡

### å®šæœŸç»´æŠ¤ä»»åŠ¡

- [ ] æ¸…ç†è¿‡æœŸçŸ­é“¾æ¥æ•°æ®
- [ ] æ•°æ®åº“æ€§èƒ½åˆ†æ
- [ ] ç¼“å­˜å‘½ä¸­ç‡ä¼˜åŒ–
- [ ] æ—¥å¿—æ–‡ä»¶è½®è½¬
- [ ] å®‰å…¨è¡¥ä¸æ›´æ–°
- [ ] å¤‡ä»½ç­–ç•¥éªŒè¯

### ç´§æ€¥å“åº”æµç¨‹

1. **æœåŠ¡å¼‚å¸¸æ£€æµ‹**ï¼šç›‘æ§å‘Šè­¦è§¦å‘
2. **å¿«é€Ÿè¯Šæ–­**ï¼šæŸ¥çœ‹å¥åº·æ£€æŸ¥å’Œæ—¥å¿—
3. **é—®é¢˜å®šä½**ï¼šä½¿ç”¨è°ƒè¯•æ¥å£æ”¶é›†ä¿¡æ¯
4. **åº”æ€¥å¤„ç†**ï¼šé‡å¯æœåŠ¡æˆ–åˆ‡æ¢æµé‡
5. **æ ¹å› åˆ†æ**ï¼šæ·±å…¥åˆ†æé—®é¢˜åŸå› 
6. **é¢„é˜²æªæ–½**ï¼šæ›´æ–°ç›‘æ§å’Œæµç¨‹

## ğŸ“š å‚è€ƒèµ„æ–™

### ç›¸å…³æ–‡æ¡£

- [å¿«é€Ÿå¼€å§‹æŒ‡å—](quickstart.md)
- [APIæ¥å£æ–‡æ¡£](api.md)
- [å¼€å‘æŒ‡å—](development.md)
- [éƒ¨ç½²æŒ‡å—](deployment.md)
- [æ€§èƒ½ä¼˜åŒ–æŒ‡å—](performance.md)
- [è¿ç»´ç›‘æ§æŒ‡å—](operations.md)

### æŠ€æœ¯è§„èŒƒ

- [Goç¼–ç è§„èŒƒ](https://golang.org/doc/effective_go.html)
- [PostgreSQLæ€§èƒ½è°ƒä¼˜](https://wiki.postgresql.org/wiki/Performance_Optimization)
- [Redisæœ€ä½³å®è·µ](https://redis.io/topics/memory-optimization)
- [Ginæ¡†æ¶æ–‡æ¡£](https://gin-gonic.com/docs/)

---

---

æˆ‘æ¥è¯¦ç»†æè¿°è¿™ä¸ªçŸ­é“¾æ¥æœåŠ¡é¡¹ç›®çš„å®Œæ•´è¿ä½œæµç¨‹ï¼Œä»ç³»ç»Ÿå¯åŠ¨åˆ°è¯·æ±‚å¤„ç†çš„å…¨è¿‡ç¨‹ã€‚
Ran tool
Ran tool
Ran tool

---

```mermaid
graph TB
    A[ç”¨æˆ·è¯·æ±‚] --> B{è¯·æ±‚ç±»å‹}
    
    %% ç³»ç»Ÿå¯åŠ¨æµç¨‹
    subgraph "ç³»ç»Ÿå¯åŠ¨æµç¨‹"
        S1[åŠ è½½é…ç½®æ–‡ä»¶] --> S2[åˆå§‹åŒ–æ—¥å¿—å™¨]
        S2 --> S3[è¿æ¥PostgreSQLæ•°æ®åº“]
        S3 --> S4[è¿æ¥Redisç¼“å­˜]
        S4 --> S5[åˆå§‹åŒ–å¸ƒéš†è¿‡æ»¤å™¨]
        S5 --> S6[åˆ›å»ºæœåŠ¡å±‚ç»„ä»¶]
        S6 --> S7[è®¾ç½®HTTPè·¯ç”±]
        S7 --> S8[å¯åŠ¨HTTPæœåŠ¡å™¨]
        S8 --> S9[ç­‰å¾…è¯·æ±‚]
    end
    
    %% åˆ›å»ºçŸ­é“¾æ¥æµç¨‹
    B -->|POST /api/v1/shorten| C[åˆ›å»ºçŸ­é“¾æ¥]
    C --> C1[éªŒè¯URLæ ¼å¼]
    C1 --> C2[æ ‡å‡†åŒ–URL]
    C2 --> C3{æ˜¯å¦è‡ªå®šä¹‰çŸ­ç }
    C3 -->|æ˜¯| C4[éªŒè¯è‡ªå®šä¹‰çŸ­ç ]
    C3 -->|å¦| C5[ç”ŸæˆéšæœºçŸ­ç ]
    C4 --> C6[æ£€æŸ¥çŸ­ç æ˜¯å¦å­˜åœ¨]
    C5 --> C7[å¸ƒéš†è¿‡æ»¤å™¨æ£€æŸ¥é‡å¤]
    C7 --> C8{å¯èƒ½å­˜åœ¨ï¼Ÿ}
    C8 -->|å¦| C9[ç¡®å®šå”¯ä¸€]
    C8 -->|æ˜¯| C10[æ•°æ®åº“äºŒæ¬¡ç¡®è®¤]
    C10 --> C11{çœŸå®å­˜åœ¨ï¼Ÿ}
    C11 -->|æ˜¯| C5
    C11 -->|å¦| C9
    C6 --> C12{çŸ­ç å·²å­˜åœ¨}
    C12 -->|æ˜¯| C13[è¿”å›å†²çªé”™è¯¯]
    C12 -->|å¦| C9
    C9 --> C14[ä¿å­˜åˆ°æ•°æ®åº“]
    C14 --> C15[æ·»åŠ åˆ°å¸ƒéš†è¿‡æ»¤å™¨]
    C15 --> C16[ç¼“å­˜åˆ°Redis]
    C16 --> C17[æ„å»ºå“åº”]
    C17 --> C18[è¿”å›çŸ­é“¾æ¥]
    
    %% é‡å®šå‘æµç¨‹  
    B -->|GET /:code| D[çŸ­é“¾æ¥é‡å®šå‘]
    D --> D1[æå–çŸ­ç ]
    D1 --> D2[Redisç¼“å­˜æŸ¥è¯¢]
    D2 --> D3{ç¼“å­˜å‘½ä¸­ï¼Ÿ}
    D3 -->|æ˜¯| D4[å¼‚æ­¥å¢åŠ è®¿é—®è®¡æ•°]
    D3 -->|å¦| D5[æ•°æ®åº“æŸ¥è¯¢]
    D5 --> D6{æ‰¾åˆ°è®°å½•ï¼Ÿ}
    D6 -->|å¦| D7[è¿”å›404é”™è¯¯]
    D6 -->|æ˜¯| D8[æ£€æŸ¥æ˜¯å¦è¿‡æœŸ]
    D8 --> D9{å·²è¿‡æœŸï¼Ÿ}
    D9 -->|æ˜¯| D10[è¿”å›410é”™è¯¯]
    D9 -->|å¦| D11[æ›´æ–°Redisç¼“å­˜]
    D11 --> D12[å¢åŠ è®¿é—®è®¡æ•°]
    D12 --> D13[302é‡å®šå‘]
    D4 --> D13
    
    %% ä¿¡æ¯æŸ¥è¯¢æµç¨‹
    B -->|GET /api/v1/info/:code| E[æŸ¥è¯¢çŸ­é“¾ä¿¡æ¯]
    E --> E1[æ•°æ®åº“æŸ¥è¯¢]
    E1 --> E2{æ‰¾åˆ°è®°å½•ï¼Ÿ}
    E2 -->|å¦| E3[è¿”å›404é”™è¯¯]
    E2 -->|æ˜¯| E4[è¿”å›è¯¦ç»†ä¿¡æ¯]
    
    %% ç»Ÿè®¡ä¿¡æ¯æµç¨‹
    B -->|GET /api/v1/stats| F[è·å–ç»Ÿè®¡ä¿¡æ¯]
    F --> F1[èšåˆæŸ¥è¯¢æ•°æ®åº“]
    F1 --> F2[è¿”å›ç»Ÿè®¡ç»“æœ]
    
    %% å¥åº·æ£€æŸ¥æµç¨‹
    B -->|GET /health| G[å¥åº·æ£€æŸ¥]
    G --> G1[æ£€æŸ¥ç³»ç»ŸçŠ¶æ€]
    G1 --> G2[è¿”å›çŠ¶æ€ä¿¡æ¯]
    
    %% ç®¡ç†åŠŸèƒ½æµç¨‹
    B -->|POST /api/v1/admin/clean| H[æ¸…ç†è¿‡æœŸé“¾æ¥]
    H --> H1[åˆ é™¤è¿‡æœŸè®°å½•]
    H1 --> H2[è¿”å›æ¸…ç†ç»“æœ]
    
    %% å†…å­˜è°ƒè¯•æµç¨‹
    B -->|GET /debug/memory| I[å†…å­˜ç»Ÿè®¡]
    I --> I1[è¯»å–å†…å­˜çŠ¶æ€]
    I1 --> I2[æ‰‹åŠ¨è§¦å‘GC]
    I2 --> I3[è¿”å›å†…å­˜ä¿¡æ¯]
```

---

# çŸ­é“¾æ¥æœåŠ¡é¡¹ç›®å®Œæ•´è¿ä½œæµç¨‹

## ğŸš€ ç³»ç»Ÿæ¶æ„æ¦‚è§ˆ

è¯¥çŸ­é“¾æ¥æœåŠ¡é‡‡ç”¨**åˆ†å±‚æ¶æ„**è®¾è®¡ï¼ŒåŒ…å«ä»¥ä¸‹æ ¸å¿ƒç»„ä»¶ï¼š
- **HTTPå±‚**ï¼šGinæ¡†æ¶å¤„ç†è·¯ç”±å’Œä¸­é—´ä»¶
- **Serviceå±‚**ï¼šä¸šåŠ¡é€»è¾‘å¤„ç†
- **Repositoryå±‚**ï¼šæ•°æ®è®¿é—®æŠ½è±¡
- **Cacheå±‚**ï¼šRedisç¼“å­˜ + å¸ƒéš†è¿‡æ»¤å™¨
- **Databaseå±‚**ï¼šPostgreSQLæŒä¹…åŒ–å­˜å‚¨

## ğŸ“‹ ç³»ç»Ÿå¯åŠ¨æµç¨‹

### 1. åˆå§‹åŒ–é˜¶æ®µ
```22:42:cmd/server/main.go
// åŠ è½½é…ç½®
cfg, err := config.Load()
if err != nil {
	log.Fatalf("Failed to load config: %v", err)
}

// åˆå§‹åŒ–æ—¥å¿—å™¨
zapLogger, err := logger.New(&cfg.App)
if err != nil {
	log.Fatalf("Failed to initialize logger: %v", err)
}
defer zapLogger.Sync()

zapLogger.Info("Starting short-url service",
	zap.String("env", cfg.App.Env),
	zap.Int("port", cfg.App.Port),
)
```

**å¯åŠ¨é¡ºåº**ï¼š
1. **é…ç½®åŠ è½½**ï¼šä»ç¯å¢ƒå˜é‡å’Œé…ç½®æ–‡ä»¶è¯»å–é…ç½®
2. **æ—¥å¿—åˆå§‹åŒ–**ï¼šè®¾ç½®ç»“æ„åŒ–æ—¥å¿—å™¨ï¼ˆZapï¼‰
3. **æ•°æ®åº“è¿æ¥**ï¼šå»ºç«‹PostgreSQLè¿æ¥æ± 
4. **Redisè¿æ¥**ï¼šè¿æ¥Rediså¹¶æµ‹è¯•è¿é€šæ€§
5. **å¸ƒéš†è¿‡æ»¤å™¨åˆå§‹åŒ–**ï¼šåˆ›å»ºæˆ–è¿æ¥å·²å­˜åœ¨çš„å¸ƒéš†è¿‡æ»¤å™¨
6. **æœåŠ¡å±‚æ„å»º**ï¼šä¾èµ–æ³¨å…¥ç»„è£…å„å±‚ç»„ä»¶
7. **HTTPæœåŠ¡å™¨å¯åŠ¨**ï¼šç›‘å¬ç«¯å£ï¼Œæ¥æ”¶è¯·æ±‚

### 2. ä¾èµ–ç»„ä»¶åˆå§‹åŒ–
```43:67:cmd/server/main.go
// åˆå§‹åŒ–æ•°æ®åº“
db, err := database.New(&cfg.Database)
if err != nil {
	zapLogger.Fatal("Failed to initialize database", zap.Error(err))
}
defer db.Close()

zapLogger.Info("Database connected successfully")

// åˆå§‹åŒ–Rediså®¢æˆ·ç«¯
redisClient := cache.NewRedisClient(&cfg.Redis, &cfg.Cache)
defer redisClient.Close()

// æµ‹è¯•Redisè¿æ¥
if err := redisClient.Ping(context.Background()); err != nil {
	zapLogger.Fatal("Failed to connect to Redis", zap.Error(err))
}

zapLogger.Info("Redis connected successfully")

// åˆå§‹åŒ–å¸ƒéš†è¿‡æ»¤å™¨
bloomFilter := cache.NewBloomFilter(redisClient, &cfg.BloomFilter)
if err := bloomFilter.Initialize(context.Background()); err != nil {
	zapLogger.Fatal("Failed to initialize bloom filter", zap.Error(err))
}
```

## ğŸ”„ æ ¸å¿ƒä¸šåŠ¡æµç¨‹

### 1. åˆ›å»ºçŸ­é“¾æ¥æµç¨‹

**APIç«¯ç‚¹**ï¼š`POST /api/v1/shorten`

#### æ­¥éª¤è¯¦è§£ï¼š

**æ­¥éª¤1ï¼šè¯·æ±‚éªŒè¯å’Œé¢„å¤„ç†**
```46:54:internal/service/shortlink.go
// éªŒè¯URL
if !utils.IsValidURL(req.URL) {
	return nil, ErrInvalidURL
}

// æ ‡å‡†åŒ–URL
normalizedURL := utils.NormalizeURL(req.URL)
```

**æ­¥éª¤2ï¼šçŸ­ç ç”Ÿæˆç­–ç•¥**
```56:68:internal/service/shortlink.go
// ç”ŸæˆçŸ­ç 
var shortCode string
var err error

if req.CustomCode != "" {
	// ä½¿ç”¨è‡ªå®šä¹‰çŸ­ç 
	if !utils.IsValidShortCode(req.CustomCode) {
		return nil, fmt.Errorf("invalid custom code format")
	}
	shortCode = req.CustomCode
} else {
	// ç”ŸæˆéšæœºçŸ­ç 
	shortCode, err = s.generateUniqueShortCode(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to generate short code: %w", err)
	}
}
```

**æ­¥éª¤3ï¼šæ™ºèƒ½é‡å¤æ£€æµ‹æœºåˆ¶**
```177:202:internal/service/shortlink.go
for i := 0; i < maxRetries; i++ {
	// ç”ŸæˆéšæœºçŸ­ç 
	shortCode, err := s.encoder.GenerateRandomCode()
	if err != nil {
		return "", err
	}

	// ä½¿ç”¨å¸ƒéš†è¿‡æ»¤å™¨å¿«é€Ÿæ£€æŸ¥
	exists, err := s.bloomFilter.Exists(ctx, shortCode)
	if err != nil {
		s.logger.Warn("bloom filter check failed", zap.Error(err))
		// å¦‚æœå¸ƒéš†è¿‡æ»¤å™¨å¤±è´¥ï¼Œç›´æ¥æ£€æŸ¥æ•°æ®åº“
		dbExists, dbErr := s.repo.ShortCodeExists(ctx, shortCode)
		if dbErr != nil {
			return "", dbErr
		}
		if !dbExists {
			return shortCode, nil
		}
	} else if !exists {
		// å¸ƒéš†è¿‡æ»¤å™¨è¯´ä¸å­˜åœ¨ï¼Œé‚£å°±ä¸å­˜åœ¨
		return shortCode, nil
	}
```

**æ­¥éª¤4ï¼šæ•°æ®æŒä¹…åŒ–å’Œç¼“å­˜**
```81:102:internal/service/shortlink.go
// ä¿å­˜åˆ°æ•°æ®åº“
if err := s.repo.CreateShortLink(ctx, shortLink); err != nil {
	return nil, fmt.Errorf("failed to save short link: %w", err)
}

// æ·»åŠ åˆ°å¸ƒéš†è¿‡æ»¤å™¨
if err := s.bloomFilter.Add(ctx, shortCode); err != nil {
	s.logger.Warn("failed to add to bloom filter", zap.Error(err))
}

// ç¼“å­˜åˆ°Redis
if err := s.cache.SetWithDefaultTTL(ctx, s.cacheKey(shortCode), normalizedURL); err != nil {
	s.logger.Warn("failed to cache short link", zap.Error(err))
}

// æ„å»ºå“åº”
response := &models.CreateShortLinkResponse{
	ShortURL:    s.buildShortURL(shortCode),
	ShortCode:   shortCode,
	OriginalURL: normalizedURL,
	ExpiresAt:   req.ExpiresAt,
	CreatedAt:   shortLink.CreatedAt,
}
```

### 2. çŸ­é“¾æ¥é‡å®šå‘æµç¨‹

**APIç«¯ç‚¹**ï¼š`GET /:code`

#### å¤šå±‚ç¼“å­˜æŸ¥è¯¢ç­–ç•¥ï¼š

**ç¬¬1å±‚ï¼šRedisç¼“å­˜æŸ¥è¯¢**
```105:117:internal/service/shortlink.go
// é¦–å…ˆæ£€æŸ¥ç¼“å­˜
originalURL, err := s.cache.Get(ctx, s.cacheKey(shortCode))
if err == nil {
	// å¼‚æ­¥å¢åŠ è®¿é—®è®¡æ•°
	go func() {
		if err := s.repo.IncrementAccessCount(context.Background(), shortCode); err != nil {
			s.logger.Error("failed to increment access count", zap.Error(err))
		}
	}()
	return originalURL, nil
}
```

**ç¬¬2å±‚ï¼šæ•°æ®åº“æŸ¥è¯¢**
```119:142:internal/service/shortlink.go
// ç¼“å­˜æœªå‘½ä¸­ï¼ŒæŸ¥è¯¢æ•°æ®åº“
if err != redis.Nil {
	s.logger.Warn("cache lookup error", zap.Error(err))
}

shortLink, err := s.repo.GetShortLinkByCode(ctx, shortCode)
if err != nil {
	if errors.Is(err, pgx.ErrNoRows) {
		return "", ErrShortCodeNotFound
	}
	return "", fmt.Errorf("failed to get short link: %w", err)
}

// æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
if shortLink.IsExpired() {
	return "", ErrExpiredLink
}

// æ›´æ–°ç¼“å­˜
if err := s.cache.SetWithDefaultTTL(ctx, s.cacheKey(shortCode), shortLink.OriginalURL); err != nil {
	s.logger.Warn("failed to update cache", zap.Error(err))
}
```

**ç¬¬3å±‚ï¼šè®¿é—®è®¡æ•°å’Œé‡å®šå‘**
```50:70:internal/handler/handler.go
originalURL, err := h.shortLinkService.GetOriginalURL(c.Request.Context(), shortCode)
if err != nil {
	h.logger.Error("failed to get original URL", zap.Error(err), zap.String("short_code", shortCode))

	switch {
	case errors.Is(err, service.ErrShortCodeNotFound):
		respondWithError(c, http.StatusNotFound, "short link not found")
	case errors.Is(err, service.ErrExpiredLink):
		respondWithError(c, http.StatusGone, "short link has expired")
	default:
		respondWithError(c, http.StatusInternalServerError, "failed to resolve short link")
	}
	return
}

c.Redirect(http.StatusFound, originalURL)
```

### 3. ä¿¡æ¯æŸ¥è¯¢æµç¨‹

**APIç«¯ç‚¹**ï¼š`GET /api/v1/info/:code`

```149:162:internal/service/shortlink.go
func (s *ShortLinkService) GetShortLinkInfo(ctx context.Context, shortCode string) (*models.ShortLinkInfo, error) {
	shortLink, err := s.repo.GetShortLinkByCode(ctx, shortCode)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, ErrShortCodeNotFound
		}
		return nil, fmt.Errorf("failed to get short link: %w", err)
	}

	return &models.ShortLinkInfo{
		ShortCode:   shortLink.ShortCode,
		OriginalURL: shortLink.OriginalURL,
		AccessCount: shortLink.AccessCount,
		CreatedAt:   shortLink.CreatedAt,
		ExpiresAt:   shortLink.ExpiresAt,
	}, nil
}
```

## ğŸ”§ ç³»ç»Ÿè¿ç»´æµç¨‹

### 1. å¥åº·æ£€æŸ¥æœºåˆ¶

**APIç«¯ç‚¹**ï¼š`GET /health`

```116:127:internal/handler/handler.go
func (h *Handler) Health(c *gin.Context) {
	health := Health{
		Status:    "ok",
		Timestamp: time.Now().UTC().Format(time.RFC3339),
		Services:  make(map[string]interface{}),
	}

	// è¿™é‡Œå¯ä»¥æ·»åŠ å¯¹å„ä¸ªæœåŠ¡çš„å¥åº·æ£€æŸ¥
	// ä¾‹å¦‚æ•°æ®åº“è¿æ¥ã€Redisè¿æ¥ç­‰

	respondWithSuccess(c, http.StatusOK, health)
}
```

### 2. å†…å­˜ç›‘æ§æœºåˆ¶

**APIç«¯ç‚¹**ï¼š`GET /debug/memory`

```129:167:internal/handler/handler.go
func (h *Handler) MemoryStats(c *gin.Context) {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)

	// æ‰‹åŠ¨è§¦å‘GC
	runtime.GC()

	// å†æ¬¡è¯»å–å†…å­˜ç»Ÿè®¡
	var m2 runtime.MemStats
	runtime.ReadMemStats(&m2)

	stats := map[string]interface{}{
		"before_gc": map[string]interface{}{
			"alloc_mb":       bToMb(m.Alloc),
			"total_alloc_mb": bToMb(m.TotalAlloc),
			"sys_mb":         bToMb(m.Sys),
			"heap_alloc_mb":  bToMb(m.HeapAlloc),
			"heap_sys_mb":    bToMb(m.HeapSys),
			"heap_idle_mb":   bToMb(m.HeapIdle),
			"heap_inuse_mb":  bToMb(m.HeapInuse),
			"stack_inuse_mb": bToMb(m.StackInuse),
			"stack_sys_mb":   bToMb(m.StackSys),
			"num_gc":         m.NumGC,
			"num_goroutine":  runtime.NumGoroutine(),
		},
		"after_gc": map[string]interface{}{
			"alloc_mb":       bToMb(m2.Alloc),
			"total_alloc_mb": bToMb(m2.TotalAlloc),
			"sys_mb":         bToMb(m2.Sys),
			"heap_alloc_mb":  bToMb(m2.HeapAlloc),
			"heap_sys_mb":    bToMb(m2.HeapSys),
			"heap_idle_mb":   bToMb(m2.HeapIdle),
			"heap_inuse_mb":  bToMb(m2.HeapInuse),
			"stack_inuse_mb": bToMb(m2.StackInuse),
			"stack_sys_mb":   bToMb(m2.StackSys),
			"num_gc":         m2.NumGC,
			"num_goroutine":  runtime.NumGoroutine(),
		},
		"gc_triggered": m2.NumGC > m.NumGC,
	}

	respondWithSuccess(c, http.StatusOK, stats)
}
```

### 3. è¿‡æœŸæ•°æ®æ¸…ç†

**APIç«¯ç‚¹**ï¼š`POST /api/v1/admin/clean`

```180:194:internal/handler/handler.go
func (h *Handler) CleanExpiredLinks(c *gin.Context) {
	deletedCount, err := h.shortLinkService.CleanExpiredLinks(c.Request.Context())
	if err != nil {
		h.logger.Error("failed to clean expired links", zap.Error(err))
		respondWithError(c, http.StatusInternalServerError, "failed to clean expired links")
		return
	}

	result := map[string]interface{}{
		"deleted_count": deletedCount,
		"timestamp":     time.Now().UTC().Format(time.RFC3339),
	}

	respondWithSuccess(c, http.StatusOK, result, "expired links cleaned successfully")
}
```

## ğŸ¯ å…³é”®æŠ€æœ¯ç‰¹æ€§

### 1. æ™ºèƒ½çŸ­ç ç”Ÿæˆç®—æ³•

**Base62ç¼–ç å®ç°**ï¼š
```67:83:internal/utils/encoder.go
// GenerateRandomCode ç”ŸæˆæŒ‡å®šé•¿åº¦çš„éšæœºçŸ­ç 
func (e *Base62Encoder) GenerateRandomCode() (string, error) {
	code := make([]byte, e.codeLength)
	for i := range code {
		randomIndex, err := rand.Int(rand.Reader, big.NewInt(e.base))
		if err != nil {
			return "", err
		}
		code[i] = e.chars[randomIndex.Int64()]
	}
	return string(code), nil
}
```

### 2. å¸ƒéš†è¿‡æ»¤å™¨ä¼˜åŒ–

**æ€§èƒ½ä¼˜åŠ¿**ï¼š
- 99.9%çš„é‡å¤æ£€æŸ¥åœ¨å†…å­˜ä¸­å®Œæˆ
- O(k)å¸¸æ•°æ—¶é—´å¤æ‚åº¦
- 100ä¸‡å®¹é‡ä»…å ç”¨çº¦1.2MBå†…å­˜

```33:49:internal/cache/bloomfilter.go
// Add å‘å¸ƒéš†è¿‡æ»¤å™¨æ·»åŠ å…ƒç´ 
func (bf *BloomFilter) Add(ctx context.Context, item string) error {
	cmd := bf.redisClient.GetClient().Do(ctx, "BF.ADD", bf.config.Key, item)
	return cmd.Err()
}

// Exists æ£€æŸ¥å…ƒç´ æ˜¯å¦å¯èƒ½å­˜åœ¨äºå¸ƒéš†è¿‡æ»¤å™¨ä¸­
func (bf *BloomFilter) Exists(ctx context.Context, item string) (bool, error) {
	cmd := bf.redisClient.GetClient().Do(ctx, "BF.EXISTS", bf.config.Key, item)
	if err := cmd.Err(); err != nil {
		return false, err
	}

	result, err := cmd.Int()
	if err != nil {
		return false, err
	}

	return result == 1, nil
}
```

### 3. å¤šå±‚æ¶æ„è®¾è®¡

**ä¸­é—´ä»¶æœºåˆ¶**ï¼š
```14:18:internal/handler/routes.go
// ä¸­é—´ä»¶
r.Use(gin.Recovery())
r.Use(LoggerMiddleware(logger))
r.Use(CORSMiddleware())
```

**è·¯ç”±åˆ†ç»„**ï¼š
```23:35:internal/handler/routes.go
// API v1 è·¯ç”±ç»„
v1 := r.Group("/api/v1")
{
	v1.POST("/shorten", handler.CreateShortLink)
	v1.GET("/info/:code", handler.GetShortLinkInfo)
	v1.GET("/stats", handler.GetStats)

	// ç®¡ç†å‘˜æ¥å£
	admin := v1.Group("/admin")
	{
		admin.POST("/clean", handler.CleanExpiredLinks)
	}
}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. å¼‚æ­¥å¤„ç†æœºåˆ¶
- **è®¿é—®è®¡æ•°å¼‚æ­¥æ›´æ–°**ï¼šé¿å…é˜»å¡é‡å®šå‘å“åº”
- **å¸ƒéš†è¿‡æ»¤å™¨å¼‚æ­¥æ·»åŠ **ï¼šå‡å°‘åˆ›å»ºå»¶è¿Ÿ

### 2. ç¼“å­˜ç­–ç•¥
- **Redisçƒ­ç‚¹æ•°æ®ç¼“å­˜**ï¼š1å°æ—¶TTL
- **è¿æ¥æ± å¤ç”¨**ï¼šæ•°æ®åº“å’ŒRedisè¿æ¥ä¼˜åŒ–
- **é¢„çƒ­æœºåˆ¶**ï¼šç³»ç»Ÿå¯åŠ¨æ—¶é¢„åŠ è½½çƒ­ç‚¹æ•°æ®

### 3. æ•°æ®åº“ä¼˜åŒ–
```11:13:sql/migrations/001_create_short_links_table.sql
-- åˆ›å»ºç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_short_links_short_code ON short_links(short_code);
CREATE INDEX IF NOT EXISTS idx_short_links_created_at ON short_links(created_at);
CREATE INDEX IF NOT EXISTS idx_short_links_expires_at ON short_links(expires_at);
```

## ğŸ”„ ç³»ç»Ÿä¼˜é›…å…³é—­

```88:104:cmd/server/main.go
// ç­‰å¾…ä¸­æ–­ä¿¡å·
quit := make(chan os.Signal, 1)
signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
<-quit

zapLogger.Info("Server shutting down...")

// ä¼˜é›…å…³é—­
ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
defer cancel()

if err := server.Shutdown(ctx); err != nil {
	zapLogger.Fatal("Server forced to shutdown", zap.Error(err))
}

zapLogger.Info("Server shutdown complete")
```

**å…³é—­æµç¨‹**ï¼š
1. ç›‘å¬ç³»ç»Ÿä¿¡å·ï¼ˆSIGINT, SIGTERMï¼‰
2. åœæ­¢æ¥æ”¶æ–°è¯·æ±‚
3. ç­‰å¾…ç°æœ‰è¯·æ±‚å®Œæˆï¼ˆæœ€å¤š30ç§’ï¼‰
4. å…³é—­æ•°æ®åº“å’ŒRedisè¿æ¥
5. æ¸…ç†èµ„æºå¹¶é€€å‡º

è¿™ä¸ªçŸ­é“¾æ¥æœåŠ¡é€šè¿‡ç²¾å¿ƒè®¾è®¡çš„æ¶æ„å’Œæµç¨‹ï¼Œå®ç°äº†é«˜æ€§èƒ½ã€é«˜å¯ç”¨çš„URLç¼©çŸ­åŠŸèƒ½ï¼ŒåŒæ—¶å…·å¤‡å®Œå–„çš„ç›‘æ§å’Œç»´æŠ¤æœºåˆ¶ã€‚